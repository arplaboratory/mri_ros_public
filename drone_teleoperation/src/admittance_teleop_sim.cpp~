#include "ros/ros.h"

#include <sstream>
#include <stdio.h>
#include <vector>
#include <fstream>
#include <iostream>
#include <unistd.h>
#include <eigen3/Eigen/Dense>
#include <string>
#include <sys/stat.h> 
#include <chrono>
#include <std_msgs/Int8.h>
#include <quadrotor_msgs/PositionCommand.h>

#include "std_srvs/SetBool.h"
#include "/home/arpl/luca_ws/src/drone_teleoperation/include/drone_teleoperation/arpl_drone_sim.h"
#include "/home/arpl/luca_ws/src/drone_teleoperation/include/drone_teleoperation/Mission.h"
#include </home/arpl/luca_ws/src/drone_teleoperation/include/drone_teleoperation/Admittance_Controller.h>
#include </home/arpl/luca_ws/src/drone_teleoperation/include/drone_teleoperation/KF.h>


using namespace std;
using namespace std::chrono;




void motors_on(arpl_drone_sim *drone, Mission *mission)
{
   //Disable Tracker Manager for position control 
   drone->disable_tracker_manager();
   if (drone->start_motors == true)
   {
      mission->arm_motors_success = drone->motors_on();
      drone->start_motors = false;
      cout << "Motors On Success" << endl;
   }

}

void take_off(arpl_drone_sim *drone, Mission *mission)
{ 
   if (mission->take_off == true)
    {
	mission->take_off_success = drone->take_off();
        mission->take_off = false;
	cout << "Take Off Success" << endl;
    }

}


void compute_target_velocities_and_accelerations(arpl_drone_sim *drone, bool init)
{
  
  float dt = 0.03;
  drone->target_vel_GF.x = (drone->des_pos_GF.x  - drone->des_pos_GF_old.x)/drone->dt;
  drone->target_vel_GF.y =  (drone->des_pos_GF.y  - drone->des_pos_GF_old.y)/drone->dt;
  drone->target_vel_GF.z =  (drone->des_pos_GF.z  - drone->des_pos_GF_old.z)/drone->dt;
  
  drone->target_acc_GF.x = (drone->target_vel_GF.x  - drone->target_vel_GF_old.x)/drone->dt;
  drone->target_acc_GF.y = (drone->target_vel_GF.y  - drone->target_vel_GF_old.y)/drone->dt;
  drone->target_acc_GF.z = (drone->target_vel_GF.z  - drone->target_vel_GF_old.z)/drone->dt;

 

  
  if (init == true)
  {
    drone->target_vel_GF.x = 0.0;
    drone->target_vel_GF.y = 0.0;
    drone->target_vel_GF.z = 0.0;
    
    drone->target_acc_GF.x = 0.0;
    drone->target_acc_GF.y = 0.0;
    drone->target_acc_GF.z = 0.0;

  }


  // if ( drone->target_acc_GF.x > drone->target_acc_GF_old.x + 1)
  // {
  //     drone->target_acc_GF.x = drone->target_acc_GF_old.x;
  // }

  // if ( drone->target_acc_GF.y > drone->target_acc_GF_old.y + 1)
  // {
  //     drone->target_acc_GF.y = drone->target_acc_GF_old.y;
  // }

  // if ( drone->target_acc_GF.x < drone->target_acc_GF_old.x - 1)
  // {
  //     drone->target_acc_GF.x = drone->target_acc_GF_old.x;
  // }
  // if ( drone->target_acc_GF.y < drone->target_acc_GF_old.y - 1)
  // {
  //     drone->target_acc_GF.y = drone->target_acc_GF_old.y;
  // }



  
}

void trajectory_generation(arpl_drone_sim *drone, Mission *mission, bool init)
{
  
  if (mission-> trajectory_case == 0)
  {
       // Generate desired Trajectory
      drone->des_pos_GF.x = 1.5*sin(0.5*mission->trajectory_time_stamp); 
      drone->des_pos_GF.y = 0; //sin(counter); //cos(counter);
      drone->des_pos_GF.z = 1.0; 
  }

  else if (mission-> trajectory_case == 1)
  {
	// The desired trajectory is defined by the marker 
      drone->des_pos_GF.x = drone->marker_unity_position.x;// drone->marker_position.x; 
      drone->des_pos_GF.y = drone->marker_unity_position.y; //sin(counter); //cos(counter);
      drone->des_pos_GF.z = drone->marker_unity_position.z;

      
      drone->average_marker_postions_on_multiple_stamps();

  }
  else
  {
	  //Come Back to Hovering 
    drone->old_pos_GF_for_hovering = drone->position_GF;
    drone->old_pos_GF_for_hovering.z = 1;
	  mission->state = 1; 
  }

  // Evaluate desired drone velocity to follow the trajectory 
  compute_target_velocities_and_accelerations(drone, init);


  float dt = 0.03;
  mission->trajectory_time_stamp = mission->trajectory_time_stamp + drone->dt;
  //cout << " mission->trajectory_time_stamp : " <<  mission->trajectory_time_stamp << endl;
}


bool init = true;
void hovering(arpl_drone_sim *drone, Mission *mission, std::chrono::duration<double,std::milli> elapesed_time,  
KF *kf_x, KF *kf_y, Admittance_Controller * IC_x, Admittance_Controller *IC_y)
{
   
   
  
     //Keep Constant Position and Altitude
     // From take off publish directly on the position command topic
       drone->target_vel_GF.x = 0.0;
   drone->target_vel_GF.y = 0.0;
   drone->target_vel_GF.z = 0.0;
   quadrotor_msgs::PositionCommand pos_cmd;
   drone->des_pos_GF = drone->old_pos_GF_for_hovering;
   pos_cmd.position = drone->des_pos_GF;
   pos_cmd.velocity = drone->target_vel_GF;
   pos_cmd.kx[0] = drone->kx[0];
   pos_cmd.kx[1] = drone->kx[1];
   pos_cmd.kx[2] = drone->kx[2];
   pos_cmd.kv[0] = drone->kv[0];
   pos_cmd.kv[1] = drone->kv[1];
   pos_cmd.kv[2] = drone->kv[2];
   drone->publish_position_cmd(pos_cmd);
   
   
  
  
   //Define the tike when to switch to the next state and start to follow the trajectory
   auto publish_period = 3000.0;
   cout << "elapesed_time.count(): " << elapesed_time.count() << endl;
   //if (elapesed_time.count() > publish_period && mission->initial_hovering == true)
   if (drone->under_unity_manipulation == true)
   {
      //Switch to state follow trajectory
      mission->state = 2;

      if (mission->state == 2 && mission->initial_hovering == true)
      {
	 //Initialize KF
         Eigen::Matrix2d P;
         Eigen::Matrix2d R; 
         double sigma_x1 = 1.0;
         double sigma_x2 = 1.0;
         //Init covariance Matrix
         P << sigma_x1, 0, 
              0, sigma_x2;
         //Init Measurement uncertanti Matrix : Uncertanty on position obs and vel obs
         R << 0.2, 0,
             0, 0.6;   
         kf_x->pass_to_class_initialization_matrices(P, R);
         kf_y->pass_to_class_initialization_matrices(P, R);

        mission->initial_hovering  = false;
      }
   }

   
   cout << "[HOVERING STATE] " << endl;
}


void trajectory_following(arpl_drone_sim *drone, Mission *mission, 
Admittance_Controller * IC_x, Admittance_Controller *IC_y, Admittance_Controller *IC_z, KF *kf_x, KF *kf_y)
{
	//Start To follow the desired trajectory
  trajectory_generation(drone, mission, init);

  geometry_msgs::Point init_comm_pos;
  geometry_msgs::Vector3 init_comm_vel;
  
  drone->comm_pos_GF = init_comm_pos;
  drone->comm_vel_GF = init_comm_vel;
  
  // Filtering the position and velocity using KF
  double dt = 0.03;

  //Filtering X axis Position and Velocity


  kf_x->calculate(drone->des_pos_GF.x, drone->target_vel_GF.x, drone->target_acc_GF.x, drone->dt);
  kf_x->state_est.x = kf_x->Obtain_KF_estimated_state()[0]; //Pos Filtered on X axis
  kf_x->state_est.y = kf_x->Obtain_KF_estimated_state()[1]; //Vel Filtered on X axis
  cout << "[TR TRACKING] [X AXIS] KF States: X: " << kf_x->state_est.x << " Y: " <<  kf_x->state_est.y << endl;
  
  
  kf_y->calculate(drone->des_pos_GF.y, drone->target_vel_GF.y, drone->target_acc_GF.y,  drone->dt); //drone->dt);
  kf_y->state_est.x = kf_y->Obtain_KF_estimated_state()[0]; //Pos Filtered on X axis
  kf_y->state_est.y = kf_y->Obtain_KF_estimated_state()[1]; //Vel Filtered on X axis
  cout << "[TR TRACKING] [Y AXIS] KF States: X: " << kf_y->state_est.x << " Y: " <<  kf_y->state_est.y << endl;
  
  

  IC_x->calculate(kf_x->state_est.x, drone->position_GF.x,   kf_x->state_est.y , drone->velocity_GF.x, drone->dt); 
  IC_y->calculate(kf_y->state_est.x, drone->position_GF.y,  kf_y->state_est.y, drone->velocity_GF.y, drone->dt); 
  
  mission->F_x = IC_x->obtain_evaluated_force();
  mission->F_y = IC_y->obtain_evaluated_force();
  
  if (init == false)
  {
    drone->comm_pos_GF.x = IC_x->obtain_commanded_position();
    drone->comm_vel_GF.x = IC_x->obtain_commanded_velocity();

    drone->comm_pos_GF.y = IC_y->obtain_commanded_position();
    drone->comm_vel_GF.y = IC_y->obtain_commanded_velocity();

     drone->comm_pos_GF.z = 1.0;
     drone->comm_vel_GF.z = 0.0;
  }

  //When the unity_flag_drone_under manipulation become false 
  //The user release the interactive hologram marker, 
  // Implement here a safety check based on distance and time before come 
  // back to hovering staqte 
  
  //Evakluate the distanc ebetween the drone and the tarcking target when is not more under 
  // manipulation 
  float x_err_squared = pow(drone->marker_unity_position.x - drone->position_GF.x, 2);
  float y_err_squared = pow(drone->marker_unity_position.y - drone->position_GF.y, 2);
  float z_err_squared = pow(drone->marker_unity_position.z - drone->position_GF.z, 2);

  float distance_3D = sqrt(x_err_squared + y_err_squared + z_err_squared);

  if (distance_3D < 0.05 && drone->under_unity_manipulation == false)
  {
    //Switch to Hoverimng state to avoid 
    // not good behaviours 
    //drone->des_pos_GF = drone->old_pos_GF_for_hovering;
    drone->old_pos_GF_for_hovering =  drone->position_GF;
    init = true;
    mission->state = 1;
  }
   
      //Keep Constant Position and Altitude
   quadrotor_msgs::PositionCommand pos_cmd;
   pos_cmd.position = drone->comm_pos_GF;
   pos_cmd.velocity = drone->comm_vel_GF;
   pos_cmd.kx[0] = drone->kx[0];
   pos_cmd.kx[1] = drone->kx[1];
   pos_cmd.kx[2] = drone->kx[2];
   pos_cmd.kv[0] = drone->kv[0];
   pos_cmd.kv[1] = drone->kv[1];
   pos_cmd.kv[2] = drone->kv[2];
   drone->publish_position_cmd(pos_cmd);

 init = false;
}



void follow_drawn_trajectory(arpl_drone_sim *drone, Mission *mission, 
Admittance_Controller * IC_x, Admittance_Controller *IC_y, Admittance_Controller *IC_z, KF *kf)
{

}

int main(int argc, char **argv)
{
  ros::init(argc, argv, "test");
  ros::NodeHandle nh;
 
  //Class Drone 
  arpl_drone_sim drone;
  Mission mission;

  KF kf_x; 
  KF kf_y;

  string folder_name;
  bool sim_mode = false;
  nh.getParam("/tele_control_params/desired_txt_folder_name", folder_name );
  nh.getParam("/tele_control_params/trajectory_method", mission.trajectory_case);
  nh.getParam("/tele_control_params/n_average_stamps", drone.avg_stamps);
 
 


  //Load Params 
  nh.param("/tele_control_params/gains/pos/x", drone.kx[0], 0.0f);
  nh.param("/tele_control_params/gains/pos/y", drone.kx[1], 0.0f);
  nh.param("/tele_control_params/gains/pos/z", drone.kx[2], 0.0f);

  nh.param("/tele_control_params/gains/vel/x", drone.kv[0], 0.0f);
  nh.param("/tele_control_params/gains/vel/y", drone.kv[1], 0.0f);
  nh.param("/tele_control_params/gains/vel/z", drone.kv[2], 0.0f);
  
  double dt_ = 0.02;
  double Ks_x, Ks_y, Ks_z = 0.5;
  double Kd_x, Kd_y, Kd_z = -0.3;
  double F_max = 10;
  double F_min = -10;
  double M = 1.7;
  double D_x, D_y, D_z = 10;
  double K_x, K_y, K_z = 2;

 

  
   // Admittance_Controller Filter Parameters  selected by user 

   nh.getParam("/tele_control_params/Ks_x", Ks_x );
   nh.getParam("/tele_control_params/Kd_X", Kd_x );
   nh.getParam("/tele_control_params/Ks_y", Ks_y );
   nh.getParam("/tele_control_params/Kd_Y", Kd_y );
   nh.getParam("/tele_control_params/Ks_z", Ks_z );
   nh.getParam("/tele_control_params/Kd_Z", Kd_z );

   nh.getParam("/tele_control_params/M", M );
   nh.getParam("/tele_control_params/D_x", D_x);
   nh.getParam("/tele_control_params/K_x", K_x);
   nh.getParam("/tele_control_params/D_y", D_y);
   nh.getParam("/tele_control_params/K_y", K_y);
   nh.getParam("/tele_control_params/D_z", D_z);
   nh.getParam("/tele_control_params/K_z", K_z);


  Admittance_Controller IC_x = Admittance_Controller(dt_, Ks_x, Kd_x, F_max, F_min, M, D_x, K_x);
  Admittance_Controller IC_y = Admittance_Controller(dt_, Ks_y, Kd_y, F_max, F_min, M, D_y, K_y);
  Admittance_Controller IC_z = Admittance_Controller(dt_, Ks_z, Kd_z, F_max, F_min, M, D_z, K_z);


   




  //Declare class PID
  
  //Create Directory for print txt files:
   string stringpath = "/home/arpl/luca_ws/DATA/TELE_CONTROL/" + folder_name + "/";
   int status = mkdir(stringpath.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
   if (status != 0)
   {
     cout << "[TELE CONTROL] Impossible to create folder to store txt output files" << endl;
   }

  //Define all the OutFile for txt transcription 
  std::ofstream outFile1(stringpath + "x_des_GF.txt");
  std::ofstream outFile2(stringpath + "y_des_GF.txt");
  std::ofstream outFile3(stringpath + "z_des_GF.txt");
  std::ofstream outFile4(stringpath + "x_GF.txt");
  std::ofstream outFile5(stringpath + "y_GF.txt");
  std::ofstream outFile6(stringpath + "z_GF.txt");
  std::ofstream outFile7(stringpath + "x_dot_des_BF.txt");
  std::ofstream outFile8(stringpath + "y_dot_des_BF.txt");
  std::ofstream outFile9(stringpath + "z_dot_des_GF.txt");
  std::ofstream outFile10(stringpath + "x_dot_GF.txt");
  std::ofstream outFile11(stringpath + "y_dot_GF.txt");
  std::ofstream outFile12(stringpath + "z_dot_GF.txt");
  std::ofstream outFile13(stringpath + "yaw.txt");
  std::ofstream outFile14(stringpath + "yaw_des.txt");
  std::ofstream outFile15(stringpath + "x_dot_des_target_GF.txt");
  std::ofstream outFile16(stringpath + "y_dot_des_target_GF.txt");
  std::ofstream outFile17(stringpath + "F_x.txt");
  std::ofstream outFile18(stringpath + "x_c.txt");
  std::ofstream outFile19(stringpath + "x_c_dot.txt");
  std::ofstream outFile20(stringpath + "x_ddot_des_target_GF.txt");
  std::ofstream outFile21(stringpath + "y_ddot_des_target_GF.txt");
  std::ofstream outFile22(stringpath + "y_c.txt");
  std::ofstream outFile23(stringpath + "y_c_dot.txt");
  std::ofstream outFile24(stringpath + "F_y.txt");
  std::ofstream outFile25(stringpath + "KF_x_pos_est.txt");
  std::ofstream outFile26(stringpath + "KF_x_vel_est.txt");
  std::ofstream outFile27(stringpath + "KF_y_pos_est.txt");
  std::ofstream outFile28(stringpath + "KF_y_vel_est.txt");

  



  //Arm Motors 
 auto start = high_resolution_clock::now();
auto time_checkPoint =  high_resolution_clock::now();
auto publish_period = 2000000.0; //3 s
auto elapesed_time = duration_cast<microseconds>(start - time_checkPoint);

   
  drone.start_motors = true;
  mission.take_off = true;
  mission.state = 0;
  
  ros::Rate r(50);
  while (nh.ok())
  {
    switch (mission.state)
    {
        //Take Off
	case 0:
        //Place Here a mission.reset function if there are some counter to re update 
	motors_on(&drone,&mission);
	
	if (elapesed_time.count()  > publish_period && mission.take_off == true && mission.arm_motors_success) 
	{
           take_off(&drone,&mission);
	   mission.take_off = false;
	   mission.arm_motors_success = false;
            
	  
	   //re initialize clock
	   time_checkPoint = high_resolution_clock::now();
	   publish_period = 3000000.0;
	}
        
	if (mission.take_off_success) 
	{
           
	   if (elapesed_time.count()  > publish_period )
	   {
	       //Go to Hovering State
	       //re initialize clock
	       time_checkPoint = high_resolution_clock::now();
	       drone.old_pos_GF_for_hovering = drone.position_GF;
	       drone.old_rpy_orientation_for_hovering = drone.rpy_orientation;
         mission.state = 1;
         mission.initial_hovering = true;
	   }
         
	 //Publish Position Command to keep the drone in the take off position along the 2 axis
	  
	  	 
          quadrotor_msgs::PositionCommand pos_cmd;
	  drone.des_pos_GF.z = 1;
          
	  pos_cmd.position = drone.des_pos_GF;
	  pos_cmd.velocity = drone.des_vel_GF;
	  pos_cmd.kx[0] = drone.kx[0];
	  pos_cmd.kx[1] = drone.kx[1];
	  pos_cmd.kx[2] = drone.kx[2];
	  pos_cmd.kv[0] = drone.kv[0];
	  pos_cmd.kv[1] = drone.kv[1];
	  pos_cmd.kv[2] = drone.kv[2];
	  
    drone.publish_position_cmd(pos_cmd);
  }

  break;
  

  case 1:
	  hovering(&drone, &mission, elapesed_time, &kf_x, &kf_y, &IC_x, &IC_y);  
	break;

	case 2:
	  trajectory_following(&drone, &mission, &IC_x, &IC_y, &IC_z, &kf_x, &kf_y);
	break;
}


//Case Switcher if selected by user via keyboard for safety reason 
if (drone.flagCaseSelectedKeyboard == true)
{
  
  if (drone.case_selected == 1)
  {
    //Hovering
    drone.old_pos_GF_for_hovering = drone.position_GF;
    drone.old_pos_GF_for_hovering.z = 1;
    mission.state = drone.case_selected;
  }
  if (drone.case_selected == 2)
  {
      mission.trajectory_case = 0;
      mission.state = 2;
  }

  if (drone.case_selected == 3)
  {
      mission.trajectory_case = 1;
       mission.state = 2;
  }

}


//Switch to Trajectory floowing using impedence if the flag is true
if (drone.under_unity_manipulation == true)
{
    mission.state = 2;
} 



   
    //PRINT TELEMETRY
    cout << "########################################################" << endl;
    cout << "X_GF: " << drone.position_GF.x << " Y_GF: " <<  drone.position_GF.y << " Z_GF: " << drone.position_GF.z << endl;
    cout << "X_vel_GF: " << drone.velocity_GF.x << " Y_vel_GF: " << drone.velocity_GF.y << " Z_vel_GF: " << drone.velocity_GF.z << endl;
    cout << "Des X_Pos_GF: " <<  drone.des_pos_GF.x << " Des Y_pos_GF: " <<  drone.des_pos_GF.y <<  endl;
    cout << "Yaw Rad: " << drone.rpy_orientation.z<< endl;
     

//Write OutFile
    outFile1 << drone.des_pos_GF.x << "\n";
    outFile2 << drone.des_pos_GF.y << "\n";
    outFile3 << drone.des_pos_GF.z << "\n";
    outFile4 << drone.position_GF.x << "\n";
    outFile5 << drone.position_GF.y << "\n";
    outFile6 << drone.position_GF.z << "\n";
    outFile7 << drone.target_vel_GF.x << "\n";
    outFile8 << drone.target_vel_GF.y << "\n";
    outFile9 << drone.target_vel_GF.z << "\n"; 
    outFile10 << drone.velocity_GF.x << "\n";
    outFile11 << drone.velocity_GF.y << "\n";
    outFile12 << drone.velocity_GF.z << "\n";
    outFile13 << drone.rpy_orientation.z << "\n";
    outFile14 <<  drone.des_yaw << "\n";
    outFile15 <<  drone.target_vel_GF.x << "\n";
    outFile16 <<  drone.target_vel_GF.y << "\n";
    outFile17 <<   mission.F_x  << "\n";
    outFile18 <<   drone.comm_pos_GF.x  << "\n";
    outFile19 <<   drone.comm_vel_GF.x  << "\n";
    outFile20 <<   drone.target_acc_GF.x  << "\n";
    outFile21 <<   drone.target_acc_GF.y   << "\n";
    outFile22 <<   drone.comm_pos_GF.y  << "\n";
    outFile23 <<   drone.comm_vel_GF.y  << "\n";
     outFile24 <<   mission.F_y  << "\n";
     outFile25 << kf_x.state_est.x << "\n";
     outFile26 << kf_x.state_est.y << "\n";
   outFile27 << kf_y.state_est.x << "\n";
    outFile28 << kf_y.state_est.y << "\n";
   
   start = high_resolution_clock::now();
   elapesed_time = duration_cast<microseconds>(start - time_checkPoint);
   
   drone.des_pos_GF_old = drone.des_pos_GF;
   drone.target_vel_GF_old = drone.target_vel_GF;
   drone.target_acc_GF_old = drone.target_acc_GF;

   drone.flagQuadSimOdom = false;
   drone.flagMarkerPosition = false;
   drone.flagCaseSelectedKeyboard = false;
   drone.flagDroneUnderManipulationFlag = false;
   drone.flagInteractiveMarkerPosition = false;

   drone.publish_voxl_tf();

   ros::spinOnce();
   r.sleep();
}
}
